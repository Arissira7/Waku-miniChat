# Waku 迷你加密聊天 - 设计说明书

## 1. 目标与范围
本项目基于 `@waku/sdk` 封装最小可用聊天层，支持单聊、群聊、删除与撤回，并提供可运行的本地演示与测试。目标是为去中心化应用提供一个安全、隐私且易于集成的通信模块。

## 2. 协议封装设计

### 2.1 节点架构选择
我们采用了 **LightPush + Filter** 的轻节点组合方案：
- **LightPush**: 允许轻节点通过全节点代理发送消息，无需维护完整的 GossipSub 网格，适合移动端和浏览器环境。
- **Filter**: 允许轻节点仅订阅感兴趣的消息主题（Content Topic），全节点在服务端进行过滤，仅下发命中的消息，极大降低了带宽和电量消耗。

### 2.2 消息格式定义 (WireMessage)
消息采用 JSON 格式序列化，版本字段用于兼容未来升级。

**聊天消息结构**:
```json
{
  "v": 1,
  "type": "chat",
  "conversationId": "string", // 会话 ID
  "messageId": "string",      // 消息唯一 ID
  "senderId": "string",       // 发送者 ID
  "senderEd25519": "base64",  // 发送者签名公钥
  "senderX25519": "base64",   // 发送者密钥交换公钥
  "timestamp": 1700000000000, // 毫秒级时间戳
  "nonce": "base64",          // 加密随机数
  "ciphertext": "base64",     // 加密后的内容载荷
  "signature": "base64"       // 消息整体签名
}
```

**撤回控制消息结构**:
```json
{
  "v": 1,
  "type": "tombstone",
  "conversationId": "string",
  "targetMessageId": "string", // 被撤回的目标消息 ID
  "senderId": "string",
  "signature": "base64",
  "timestamp": 1700000000000
}
```

## 3. Topic 规划与分层架构
Waku 协议使用两层 Topic 来管理消息路由与分发，本项目严格遵循此设计。

### 3.1 核心概念辨析
- **PubSub Topic (管道/路由)**: 
    - 这是网络层的概念（GossipSub）。你可以把它想象成一条物理光纤或一个广播频段。
    - 本项目复用了 Waku 默认的 PubSub Topic（如 `/waku/2/default-waku/proto`），这意味着我们的流量与 Waku 网络上的其他通用流量共用同一个“物理通道”，享受现成的节点中继服务。
- **Content Topic (标签/应用)**: 
    - 这是应用层的概念。你可以把它想象成包裹上的“收件人标签”。
    - 在同一条 PubSub Topic 管道中，流动着成千上万种消息。我们的 SDK 通过 Content Topic 告诉 Waku 节点：“我只关心贴了这个标签的消息，其他的不要发给我”。

### 3.2 本项目设计
- **格式**: `/waku-chat/1/{conversationId}/proto`
    - `waku-chat`: 应用标识
    - `1`: 协议版本
    - `{conversationId}`: 动态生成的会话 ID。对于单聊，使用两个用户公钥排序后的组合哈希；对于群聊，使用房间唯一标识。
- **设计收益**: 
    - **隔离性**: 不同的聊天室拥有完全独立的 Content Topic，实现了物理层面的流量隔离。
    - **逻辑解耦**: 路由层只管转发（PubSub），应用层只管业务（Content Topic）。

## 4. 安全方案

### 4.1 加密算法选择
我们没有使用 Waku 自带的 Noise 层（避免版本绑定），而是在应用层实现了端到端加密：
- **对称加密 (XChaCha20-Poly1305)**: 用于加密消息载荷。相比 AES-GCM，它在没有硬件加速的设备上性能更好，且 nonce 更长，避免了随机数碰撞风险。
- **签名 (Ed25519)**: 用于消息签名，确保发送者身份不可篡改。
- **密钥协商 (X25519 + HKDF)**: 
    - 单聊：通过 ECDH 协商共享密钥，再经 HKDF 派生出会话密钥。
    - 群聊：使用预共享的群组密钥，经 HKDF 派生会话密钥。

### 4.2 安全性保证
- **机密性**: 只有持有正确密钥的会话参与者才能解密 `ciphertext`。
- **完整性**: Poly1305 算法确保密文在传输过程中未被篡改。
- **身份认证**: 每一条消息都包含发送者的 Ed25519 签名，接收方会验证签名是否匹配 `senderId`。

### 4.3 消息唯一标识
使用自定义 `messageId` 生成算法：对 `conversationId|senderId|nonce|ciphertext|timestamp` 进行 SHA-256 后 Base64 编码。这不仅用于去重，也为撤回操作提供了可验证的目标索引。

## 5. 撤回与删除边界说明

### 5.1 实现机制 (Tombstone)
由于 Waku 是去中心化网络，无法直接从网络节点中“物理删除”已分发的消息。我们采用 **Tombstone（墓碑）机制**：
1. **撤回**: 用户发送一条类型为 `tombstone` 的控制消息，包含目标消息的 `messageId`。
2. **处理**: 接收端 SDK 收到墓碑消息后，验证签名权限（仅发送者或管理员可撤回），然后在本地数据库/缓存中将原消息标记为 `revoked`。
3. **展示**: UI 层根据状态隐藏原消息内容，显示“消息已撤回”。

### 5.2 现实边界与权衡
- **非强制性**: 撤回逻辑依赖于客户端的诚实实现。我们无法阻止恶意修改过的客户端忽略墓碑消息并继续展示被撤回的内容。
- **最终一致性**: 撤回消息本质上也是一条普通消息，依赖于网络传播。如果接收方离线，只有在下次上线同步消息时才会看到撤回效果。

## 6. 本地网络与测试
- **环境**: 使用 `@waku/run` 启动本地 nwaku 节点。
- **配置**: 两个节点互相连接形成私有网络，提供 LightPush 和 Filter 服务。
- **限制**: 当前 Demo 仅展示在线期间消息，不拉取 Store 历史，以保持最小可用实现的简洁性。
